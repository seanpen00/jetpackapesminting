{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defineProperties = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar ethjsUtil = __importStar(require(\"ethjs-util\"));\n\nvar rlp = __importStar(require(\"rlp\"));\n\nvar bytes_1 = require(\"./bytes\");\n/**\r\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\r\n * @param self the `Object` to define properties on\r\n * @param fields an array fields to define. Fields can contain:\r\n * * `name` - the name of the properties\r\n * * `length` - the number of bytes the field can have\r\n * * `allowLess` - if the field can be less than the length\r\n * * `allowEmpty`\r\n * @param data data to be validated against the definitions\r\n * @deprecated\r\n */\n\n\nexports.defineProperties = function (self, fields, data) {\n  self.raw = [];\n  self._fields = []; // attach the `toJSON`\n\n  self.toJSON = function (label) {\n    if (label === void 0) {\n      label = false;\n    }\n\n    if (label) {\n      var obj_1 = {};\n\n      self._fields.forEach(function (field) {\n        obj_1[field] = \"0x\" + self[field].toString('hex');\n      });\n\n      return obj_1;\n    }\n\n    return bytes_1.baToJSON(self.raw);\n  };\n\n  self.serialize = function serialize() {\n    return rlp.encode(self.raw);\n  };\n\n  fields.forEach(function (field, i) {\n    self._fields.push(field.name);\n\n    function getter() {\n      return self.raw[i];\n    }\n\n    function setter(v) {\n      v = bytes_1.toBuffer(v);\n\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0);\n      }\n\n      if (field.allowLess && field.length) {\n        v = bytes_1.unpadBuffer(v);\n        assert_1.default(field.length >= v.length, \"The field \" + field.name + \" must not have more \" + field.length + \" bytes\");\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        assert_1.default(field.length === v.length, \"The field \" + field.name + \" must have byte length of \" + field.length);\n      }\n\n      self.raw[i] = v;\n    }\n\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter\n    });\n\n    if (field.default) {\n      self[field.name] = field.default;\n    } // attach alias\n\n\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter\n      });\n    }\n  }); // if the constuctor is passed data\n\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');\n    }\n\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data);\n    }\n\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data');\n      } // make sure all the items are buffers\n\n\n      data.forEach(function (d, i) {\n        self[self._fields[i]] = bytes_1.toBuffer(d);\n      });\n    } else if (typeof data === 'object') {\n      var keys_1 = Object.keys(data);\n      fields.forEach(function (field) {\n        if (keys_1.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n        if (keys_1.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n      });\n    } else {\n      throw new Error('invalid data');\n    }\n  }\n};","map":{"version":3,"sources":["../src/object.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.defineProperties = void 0;\r\nvar assert_1 = __importDefault(require(\"assert\"));\r\nvar ethjsUtil = __importStar(require(\"ethjs-util\"));\r\nvar rlp = __importStar(require(\"rlp\"));\r\nvar bytes_1 = require(\"./bytes\");\r\n/**\r\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\r\n * @param self the `Object` to define properties on\r\n * @param fields an array fields to define. Fields can contain:\r\n * * `name` - the name of the properties\r\n * * `length` - the number of bytes the field can have\r\n * * `allowLess` - if the field can be less than the length\r\n * * `allowEmpty`\r\n * @param data data to be validated against the definitions\r\n * @deprecated\r\n */\r\nexports.defineProperties = function (self, fields, data) {\r\n    self.raw = [];\r\n    self._fields = [];\r\n    // attach the `toJSON`\r\n    self.toJSON = function (label) {\r\n        if (label === void 0) { label = false; }\r\n        if (label) {\r\n            var obj_1 = {};\r\n            self._fields.forEach(function (field) {\r\n                obj_1[field] = \"0x\" + self[field].toString('hex');\r\n            });\r\n            return obj_1;\r\n        }\r\n        return bytes_1.baToJSON(self.raw);\r\n    };\r\n    self.serialize = function serialize() {\r\n        return rlp.encode(self.raw);\r\n    };\r\n    fields.forEach(function (field, i) {\r\n        self._fields.push(field.name);\r\n        function getter() {\r\n            return self.raw[i];\r\n        }\r\n        function setter(v) {\r\n            v = bytes_1.toBuffer(v);\r\n            if (v.toString('hex') === '00' && !field.allowZero) {\r\n                v = Buffer.allocUnsafe(0);\r\n            }\r\n            if (field.allowLess && field.length) {\r\n                v = bytes_1.unpadBuffer(v);\r\n                assert_1.default(field.length >= v.length, \"The field \" + field.name + \" must not have more \" + field.length + \" bytes\");\r\n            }\r\n            else if (!(field.allowZero && v.length === 0) && field.length) {\r\n                assert_1.default(field.length === v.length, \"The field \" + field.name + \" must have byte length of \" + field.length);\r\n            }\r\n            self.raw[i] = v;\r\n        }\r\n        Object.defineProperty(self, field.name, {\r\n            enumerable: true,\r\n            configurable: true,\r\n            get: getter,\r\n            set: setter,\r\n        });\r\n        if (field.default) {\r\n            self[field.name] = field.default;\r\n        }\r\n        // attach alias\r\n        if (field.alias) {\r\n            Object.defineProperty(self, field.alias, {\r\n                enumerable: false,\r\n                configurable: true,\r\n                set: setter,\r\n                get: getter,\r\n            });\r\n        }\r\n    });\r\n    // if the constuctor is passed data\r\n    if (data) {\r\n        if (typeof data === 'string') {\r\n            data = Buffer.from(ethjsUtil.stripHexPrefix(data), 'hex');\r\n        }\r\n        if (Buffer.isBuffer(data)) {\r\n            data = rlp.decode(data);\r\n        }\r\n        if (Array.isArray(data)) {\r\n            if (data.length > self._fields.length) {\r\n                throw new Error('wrong number of fields in data');\r\n            }\r\n            // make sure all the items are buffers\r\n            data.forEach(function (d, i) {\r\n                self[self._fields[i]] = bytes_1.toBuffer(d);\r\n            });\r\n        }\r\n        else if (typeof data === 'object') {\r\n            var keys_1 = Object.keys(data);\r\n            fields.forEach(function (field) {\r\n                if (keys_1.indexOf(field.name) !== -1)\r\n                    self[field.name] = data[field.name];\r\n                if (keys_1.indexOf(field.alias) !== -1)\r\n                    self[field.alias] = data[field.alias];\r\n            });\r\n        }\r\n        else {\r\n            throw new Error('invalid data');\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=object.js.map"]},"metadata":{},"sourceType":"script"}